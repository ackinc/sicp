#lang racket
(define (make-tree entry) (mcons 'tree (mcons entry (mcons null null))))
(define (entry tree) (mcar (mcdr tree)))
(define (left tree) (mcar (mcdr (mcdr tree))))
(define (right tree) (mcdr (mcdr (mcdr tree))))

(define (tree? x) (and (mpair? x) (eq? (mcar x) 'tree)))
(define (set-entry! tree x) (set-mcar! (mcdr tree) x))
(define (set-left-subtree! tree x) (set-mcar! (mcdr (mcdr tree)) (make-tree x)))
(define (set-right-subtree! tree x) (set-mcdr! (mcdr (mcdr tree)) (make-tree x)))

(define (make-record key val) (mcons key val))
(define (key-record record) (mcar record))
(define (val-record record) (mcdr record))
(define (set-val-record! record x) (set-mcdr! record x))

(define (make-table)
  (let ((table (mcons 'table null)))

    (define (empty?) (null? (mcdr table)))

    (define (traverse key tree)
      (if (null? tree)
          (error "traverse -- tree cannot be null")
          (let ((tree-key (key-record (entry tree))))
            (cond ((eq? key tree-key) tree)
                  (else (let ((lt (left tree))
                              (rt (right tree)))
                          (if (symbol<? key tree-key)
                              (if (null? lt) tree (traverse key lt))
                              (if (null? rt) tree (traverse key rt)))))))))

    (define (assoc key tree)
      (if (null? tree)
          #f
          (let* ((record (entry (traverse key tree)))
                 (cur-key (key-record record)))
            (cond ((eq? cur-key key) record)
                  (else #f)))))

    (define (lookup keys)
      (define (helper remaining-keys tree-or-value)
        (cond ((null? remaining-keys) tree-or-value)
              ((not (tree? tree-or-value)) #f)
              (else (let ((record (assoc (car remaining-keys) tree-or-value)))
                      (if record
                          (helper (cdr remaining-keys) (val-record record))
                          #f)))))
      (if (null? keys)
          (error "lookup -- keys cannot be empty list")
          (helper keys (mcdr table))))

    (define (insert! keys value)
      (define (helper remaining-keys tree)
        (let* ((first-key (car remaining-keys))
               (rest-keys (cdr remaining-keys))
               (record-tree (traverse first-key tree))
               (record (entry record-tree))
               (record-key (key-record record)))
          (if (null? rest-keys) ; base case - only one key
              (cond ((eq? record-key first-key) (set-val-record! record value))
                    ((symbol<? record-key first-key) (set-right-subtree! record-tree (make-record first-key value)))
                    (else (set-left-subtree! record-tree (make-record first-key value))))
              (cond ((eq? record-key first-key) (if (tree? (val-record record))
                                                    (helper rest-keys (val-record record))
                                                    (begin (set-val-record! record (make-tree (make-record (car rest-keys) value)))
                                                           (helper rest-keys (val-record record)))))
                    ((symbol<? record-key first-key) (begin (set-right-subtree! record-tree (make-record first-key value))
                                                            (helper remaining-keys (right record-tree))))
                    (else (begin (set-left-subtree! record-tree (make-record first-key value))
                                 (helper remaining-keys (left record-tree))))))))
      (cond ((null? keys) (error "insert! -- called with empty list of keys"))
            ((empty?) (begin (set-mcdr! table (make-tree (make-record (car keys) value)))
                             (helper keys (mcdr table))))
            (else (helper keys (mcdr table)))))

    (define (dispatch m)
      (cond ((eq? m 'empty?) (empty?))
            ((eq? m 'insert!) insert!)
            ((eq? m 'lookup) lookup)
            (else (error "dispatch -- invalid message" m))))

    dispatch))

(define (insert! key val tree) ((tree 'insert!) key val))
(define (lookup key tree) ((tree 'lookup) key))


; TESTS
(define t (make-table))

(display "tree starts off empty")(newline)
(eq? (t 'empty?) #t)

(display "single-key tests")(newline)
(insert! '(m) 13 t)
(insert! '(d) 4 t)
(insert! '(b) 2 t)
(insert! '(e) 5 t)
(insert! '(x) 23 t)
(insert! '(n) 14 t)
(insert! '(z) 26 t)
(insert! '(y) 25 t)

(eq? (t 'empty?) #f)
(eq? (lookup '(m) t) 13)
(eq? (lookup '(d) t) 4)
(eq? (lookup '(b) t) 2)
(eq? (lookup '(e) t) 5)
(eq? (lookup '(x) t) 23)
(eq? (lookup '(n) t) 14)
(eq? (lookup '(z) t) 26)
(eq? (lookup '(y) t) 25)
(eq? (lookup '(a) t) #f)

(display "multi-key tests")(newline)
(insert! '(e f) 56 t)
(insert! '(g h i j) 7890 t)
(insert! '(o v u t) 'ovut t)
(insert! '(o v u m) 'ovum t)

(eq? (lookup '(e f) t) 56)
(eq? (lookup '(g h i j) t) 7890)
(eq? (lookup '(o v u t) t) 'ovut)
(eq? (lookup '(o v u m) t) 'ovum)

(display "overwriting tests")(newline)
(insert! '(e) 5 t)
(insert! '(o) 5 t)

(eq? (lookup '(e) t) 5)
(eq? (lookup '(o) t) 5)
(eq? (lookup '(e f) t) #f)
(eq? (eq? (lookup '(o v u t) t) 'ovut) #f)

(insert! '(g h i j k l) 789012 t)
(eq? (lookup '(g h i j k l) t) 789012)
(eq? (eq? (lookup '(g h i j) t) 7890) #f)