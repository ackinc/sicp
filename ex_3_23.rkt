#lang racket
(define (make-deque) (mcons null null))
(define (front-ptr dq) (mcar dq))
(define (rear-ptr dq) (mcdr dq))
(define (set-front-ptr! dq node) (set-mcar! dq node))
(define (set-rear-ptr! dq node) (set-mcdr! dq node))

(define (make-node val) (mcons val (mcons null null)))
(define (value node) (mcar node))
(define (next-ptr node) (mcar (mcdr node)))
(define (prev-ptr node) (mcdr (mcdr node)))
(define (set-next-ptr! node another-node) (set-mcar! (mcdr node) another-node))
(define (set-prev-ptr! node another-node) (set-mcdr! (mcdr node) another-node))

(define (empty-deque? dq) (null? (front-ptr dq)))

(define (front-deque dq) (if (empty-deque? dq)
                             (error "front-deque -- called on empty deque")
                             (value (front-ptr dq))))
(define (rear-deque dq) (if (empty-deque? dq)
                            (error "rear-deque -- called on empty deque")
                            (value (rear-ptr dq))))

(define (insert-front! dq val)
  (let ((node (make-node val)))
    (if (empty-deque? dq)
        (begin (set-front-ptr! dq node)
               (set-rear-ptr! dq node)
               dq)
        (let ((e1 (front-ptr dq)))
          (begin (set-prev-ptr! e1 node)
                 (set-next-ptr! node e1)
                 (set-front-ptr! dq node)
                 dq)))))

(define (insert-rear! dq val)
  (let ((node (make-node val)))
    (if (empty-deque? dq)
        (begin (set-front-ptr! dq node)
               (set-rear-ptr! dq node)
               dq)
        (let ((e1 (rear-ptr dq)))
          (begin (set-prev-ptr! node e1)
                 (set-next-ptr! e1 node)
                 (set-rear-ptr! dq node)
                 dq)))))

(define (delete-front! dq)
  (cond ((empty-deque? dq) (error "delete-front! -- called on empty deque"))
        ((eq? (front-ptr dq) (rear-ptr dq)) (begin (set-front-ptr! dq null)
                                                   (set-rear-ptr! dq null)
                                                   dq))
        (else (begin (set-front-ptr! dq (next-ptr (front-ptr dq)))
                     (set-prev-ptr! (front-ptr dq) null)
                     dq))))

(define (delete-rear! dq)
  (cond ((empty-deque? dq) (error "delete-rear! -- called on empty deque"))
        ((eq? (front-ptr dq) (rear-ptr dq)) (begin (set-front-ptr! dq null)
                                                   (set-rear-ptr! dq null)
                                                   dq))
        (else (begin (set-rear-ptr! dq (prev-ptr (rear-ptr dq)))
                     (set-next-ptr! (rear-ptr dq) null)
                     dq))))

; TESTS
(define dq (make-deque))
(eq? (empty-deque? dq) #t)

(insert-front! dq 1)
(insert-front! dq 2)
(insert-front! dq 3)

(eq? (front-deque dq) 3)
(eq? (rear-deque dq) 1)

(insert-rear! dq 4)
(insert-rear! dq 5)
(insert-rear! dq 6)

(eq? (front-deque dq) 3)
(eq? (rear-deque dq) 6)

(delete-front! dq)
(delete-front! dq)
(eq? (front-deque dq) 1)
(eq? (rear-deque dq) 6)

(delete-rear! dq)
(delete-rear! dq)
(eq? (front-deque dq) 1)
(eq? (rear-deque dq) 4)